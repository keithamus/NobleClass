<!DOCTYPE html>
<html>
<head>
    <title>NobleClass</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" media="all" href="doc_theme/main.css" />
    <script type="text/javascript">
        document.addEventListener('click', function (e) {
            if (e.target.tagName === 'DT') {
                [].forEach.call(document.querySelectorAll('dt.expanded'), function (el) {
                    if (el !== e.target) el.classList.remove('expanded');
                });
                e.target.classList.toggle('expanded');
            }
        });
    </script>
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="header">
                <h1>NobleClass</h1>
            </div>
            <blockquote>
                <p>Â© Keith Cirkel</p>
                <p>NobleClass may be freely distributed under the MIT license.</p>
                <p>For all details and documentation:
                <a href="http://github.com/keithamus/NobleClass">http://github.com/keithamus/NobleClass</a></p>
            </blockquote>
            <p>
                This is the spec documentation for NobleClass, generated by Mocha. If you want to
                see more detailed documentation about NobleClass, check out the <a href="index.html">
                index.html page</a>
            </p>    <section class="suite">
      <h1>Class</h1>
      <dl>
        <dt>can be newed up</dt>
        <dd><pre><code>instance = new Class();

        instance
            .should.be.instanceof(Class);</code></pre></dd>
        <dt>cannot be modified in the prototype</dt>
        <dd><pre><code>(fn = function () { delete Class.prototype.on; })
            .should.throw(/delete|non-configurable/);

        (fn = function () { Class.prototype.on = true; })
            .should.throw(/read.?only/);

        (fn = function () { delete Class.prototype.emit; })
            .should.throw(/delete|non-configurable/);

        (fn = function () { Class.prototype.emit = true; })
            .should.throw(/read.?only/);

        (fn = function () { delete Class.prototype.off; })
            .should.throw(/delete|non-configurable/);

        (fn = function () { Class.prototype.off = true; })
            .should.throw(/read.?only/);

        (fn = function () { delete Class.prototype.once; })
            .should.throw(/delete|non-configurable/);

        (fn = function () { Class.prototype.once = true; })
            .should.throw(/read.?only/);</code></pre></dd>
        <section class="suite">
          <h1>extended child</h1>
          <dl>
            <dt>is instance is instanceof Extended</dt>
            <dd><pre><code>instance
                .should.be.instanceof(Extended);</code></pre></dd>
            <dt>is instance is instanceof Class</dt>
            <dd><pre><code>instance
                .should.be.instanceof(Class);</code></pre></dd>
            <dt>has a reference to Class via .super</dt>
            <dd><pre><code>Extended.super
                .should.equal(Class);</code></pre></dd>
            <dt>inherits prototype properties</dt>
            <dd><pre><code>instance.on
                .should.be.a('function')
                .and.equal(Class.prototype.on);

            instance.once
                .should.be.a('function')
                .and.equal(Class.prototype.once);

            instance.off
                .should.be.a('function')
                .and.equal(Class.prototype.off);

            instance.emit
                .should.be.a('function')
                .and.equal(Class.prototype.emit);</code></pre></dd>
            <dt>has its own prototype properties</dt>
            <dd><pre><code>Extended.prototype.aProperty
                .should.equal(true);

            Extended.prototype.aFn
                .should.be.a('function');</code></pre></dd>
            <dt>has static properties inherited from Class</dt>
            <dd><pre><code>Extended.extend
                .should.equal(Class.extend);</code></pre></dd>
            <dt>has its own static properties</dt>
            <dd><pre><code>Extended.staticProp
                .should.equal(true);</code></pre></dd>
            <dt>can override Class prototype properties (e.g `on`)</dt>
            <dd><pre><code>var onFn = function () {},
    onceFn = function () {},
    offFn = function () {},
    emitFn = function () {};

Extended = Class.extend({
    on: onFn,
    once: onceFn,
    off: offFn,
    emit: emitFn,
});

Extended.prototype.on
    .should.equal(onFn);

(new Extended()).on
    .should.equal(onFn);

Extended.prototype.once
    .should.equal(onceFn);

(new Extended()).once
    .should.equal(onceFn);

Extended.prototype.off
    .should.equal(offFn);

(new Extended()).off
    .should.equal(offFn);

Extended.prototype.emit
    .should.equal(emitFn);

(new Extended()).emit
    .should.equal(emitFn);</code></pre></dd>
            <dt>can override Class static properties (e.g `extend`)</dt>
            <dd><pre><code>var extendFn = function () {};

Extended = Class.extend({}, { extend: extendFn });

Extended.extend
    .should.equal(extendFn);</code></pre></dd>
            <dt>does not copy over read-only properties</dt>
            <dd><pre><code>Extended = Class.extend({ name: 'a', length: 4 });

            Extended.name
                .should.equal('subClass');

            Extended.length
                .should.equal(0);</code></pre></dd>
            <section class="suite">
              <h1>a child inheriting from child (multiple inheritence)</h1>
              <dl>
                <dt>is instance is instanceof ExtendedChild</dt>
                <dd><pre><code>instance
                    .should.be.instanceof(ExtendedChild);</code></pre></dd>
                <dt>is instance is instanceof Extended</dt>
                <dd><pre><code>instance
                    .should.be.instanceof(Extended);</code></pre></dd>
                <dt>is instance is instanceof Class</dt>
                <dd><pre><code>instance
                    .should.be.instanceof(Class);</code></pre></dd>
                <dt>has a reference to Extended via .super</dt>
                <dd><pre><code>ExtendedChild.super
                    .should.equal(Extended);</code></pre></dd>
                <dt>has a reference to Class via .super</dt>
                <dd><pre><code>ExtendedChild.super.super
                    .should.equal(Class);</code></pre></dd>
                <dt>inherits prototype properties</dt>
                <dd><pre><code>ExtendedChild = Extended.extend();
                instance = new ExtendedChild();

                instance.on
                    .should.be.a('function')
                    .and.equal(Class.prototype.on);

                instance.once
                    .should.be.a('function')
                    .and.equal(Class.prototype.once);

                instance.off
                    .should.be.a('function')
                    .and.equal(Class.prototype.off);

                instance.emit
                    .should.be.a('function')
                    .and.equal(Class.prototype.emit);

                instance.aFn
                    .should.be.a('function')
                    .and.equal(Extended.prototype.aFn);

                instance.aProperty
                    .should.equal(true);</code></pre></dd>
                <dt>has its own prototype properties, overriding parent</dt>
                <dd><pre><code>ExtendedChild.prototype.aProperty
                    .should.equal(false);

                ExtendedChild.prototype.aFn
                    .should.be.a('function');

                ExtendedChild.prototype.aFn
                    .should.not.equal(Extended.prototype.aFn);</code></pre></dd>
                <dt>has static properties inherited from Class</dt>
                <dd><pre><code>ExtendedChild.extend
                    .should.equal(Class.extend);</code></pre></dd>
                <dt>has static properties inherited from Extended</dt>
                <dd><pre><code>ExtendedChild.staticProp
                    .should.equal(true);</code></pre></dd>
                <dt>has its own static properties</dt>
                <dd><pre><code>ExtendedChild.staticProp
                    .should.equal(true);</code></pre></dd>
                <dt>can override Class prototype properties (e.g `on`)</dt>
                <dd><pre><code>var onFn = function () {},
    onceFn = function () {},
    offFn = function () {},
    emitFn = function () {},
    aFn = function () {};

ExtendedChild = Extended.extend({
    on: onFn,
    once: onceFn,
    off: offFn,
    emit: emitFn,
    aFn: aFn
});

ExtendedChild.prototype.on
    .should.equal(onFn);

(new ExtendedChild()).on
    .should.equal(onFn);

ExtendedChild.prototype.once
    .should.equal(onceFn);

(new ExtendedChild()).once
    .should.equal(onceFn);

ExtendedChild.prototype.off
    .should.equal(offFn);

(new ExtendedChild()).off
    .should.equal(offFn);

ExtendedChild.prototype.emit
    .should.equal(emitFn);

(new ExtendedChild()).emit
    .should.equal(emitFn);

ExtendedChild.prototype.aFn
    .should.equal(aFn);

(new ExtendedChild()).aFn
    .should.equal(aFn);</code></pre></dd>
                <dt>can override Class static properties (e.g `extend`)</dt>
                <dd><pre><code>var extendFn = function () {};

ExtendedChild = Extended.extend({}, { extend: extendFn });

ExtendedChild.extend
    .should.equal(extendFn);</code></pre></dd>
                <dt>can be extended in the same way</dt>
                <dd><pre><code>var C = ExtendedChild.extend({});
                instance = new C();

                instance
                    .should.be.instanceof(C);

                C.extend
                    .should.equal(Class.extend);

                instance.on
                    .should.equal(Class.prototype.on);

                instance.aFn
                    .should.equal(ExtendedChild.prototype.aFn);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>events</h1>
          <dl>
            <section class="suite">
              <h1>.on</h1>
              <dl>
                <dt>is given an event name, and a listener</dt>
                <dd><pre><code>instance.on('eventname', listener)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;</code></pre></dd>
                <dt>will fire the listener multiple times</dt>
                <dd><pre><code>instance.on('eventname', listener)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledTwice;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledThrice;</code></pre></dd>
                <dt>can be given an optional context</dt>
                <dd><pre><code>instance.on('eventname', listener, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);</code></pre></dd>
                <dt>can include multiple event names in one string</dt>
                <dd><pre><code>instance.on('eventname anotherevent', listener, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);</code></pre></dd>
                <dt>can be given an object of events with listener functions</dt>
                <dd><pre><code>instance.on({ eventname: listener, anotherevent: listener }, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledTwice;</code></pre></dd>
                <dt>can be given an object of events with strings pointing to functions on the context</dt>
                <dd><pre><code>context = { listener: listener };

                instance.on({ eventname: 'listener', anotherevent: 'listener' }, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledTwice;

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledTwice;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.emit</h1>
              <dl>
                <dt>is given an eventname, where it will fire all attached events</dt>
                <dd><pre><code>instance
                    .on('eventname', listener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will fire all event listeners on that event</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener)
                    .on('eventname', anotherListener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will fire any event listeners without a context, with the context of the instance</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('eventname', anotherListener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                anotherListener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(instance);</code></pre></dd>
                <dt>will send any arguments provided to the event listeners</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('eventname', anotherListener)
                    .emit('eventname', 1, 2, 3, context)
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly(1, 2, 3, context)
                    .and.always.have.been.calledOn(context);

                anotherListener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly(1, 2, 3, context)
                    .and.always.have.been.calledOn(instance);</code></pre></dd>
                <dt>will fire an &quot;all&quot; event for every other event fired</dt>
                <dd><pre><code>var anotherListener = this.spy(),
                    allListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('anotherevent', anotherListener)
                    .on('all', allListener)
                    .emit('eventname', 1, 2, 3, context)
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly(1, 2, 3, context)
                    .and.always.have.been.calledOn(context);

                allListener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly('eventname', 1, 2, 3, context)
                    .and.always.have.been.calledOn(instance);

                allListener.reset();

                instance.emit('anotherevent', 1, 2, 3, context);

                anotherListener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly(1, 2, 3, context)
                    .and.always.have.been.calledOn(instance);

                allListener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledWithExactly('anotherevent', 1, 2, 3, context)
                    .and.always.have.been.calledOn(instance);</code></pre></dd>
                <dt>will throw an error if an emit(&quot;error&quot;) event is called, but no one is listening</dt>
                <dd><pre><code>(fn = function () { instance.emit('error', new Error('Hi!')); })
                    .should.throw('Hi!');</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.off</h1>
              <dl>
                <dt>is given an event name, and a listener</dt>
                <dd><pre><code>instance.off('eventname', listener)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;</code></pre></dd>
                <dt>will remove a bound (.on'd) event listener from the event name</dt>
                <dd><pre><code>instance
                    .on('eventname', listener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance
                    .off('eventname', listener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will remove a bound (.on'd) event listener that was given a context, when only referencing the function</dt>
                <dd><pre><code>instance
                    .on('eventname', listener, context)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance
                    .off('eventname', listener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>can include multiple event names in one string</dt>
                <dd><pre><code>instance
                    .on('eventname', listener, context)
                    .on('anotherevent', listener, context)
                    .on('keptevent', listener, context)
                    .emit('eventname')
                    .emit('anotherevent')
                    .emit('keptevent')
                        .should.equal(instance);

                listener
                    .should.have.been.calledThrice;

                listener.reset();

                instance
                    .off('eventname anotherevent', listener)
                    .emit('eventname')
                    .emit('anotherevent')
                        .should.equal(instance);

                listener
                    .should.not.have.been.called;

                instance
                    .emit('keptevent');

                listener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will match against contexts when removing multiple of the same listeners with different contexts</dt>
                <dd><pre><code>var anotherContext = { second: true };

                instance
                    .on('eventname', listener, context)
                    .on('eventname', listener, anotherContext)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledTwice
                    .and.have.been.calledOn(context)
                    .and.have.been.calledOn(anotherContext);

                listener.reset();

                instance.off('eventname', listener, context)
                    .should.equal(instance);

                listener
                    .should.not.have.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(anotherContext);

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledTwice
                    .and.always.have.been.calledOn(anotherContext);</code></pre></dd>
                <dt>will remove all listeners on an event if only given a name</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('eventname', anotherListener)
                    .emit('eventname')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                instance
                    .off('eventname')
                    .emit('eventname');

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                instance
                    .emit('eventname');

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will reset all events, if given &quot;*&quot; as an eventname</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('anotherevent', anotherListener)
                    .emit('eventname')
                    .emit('anotherevent')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                instance
                    .off('*')
                    .emit('eventname')
                    .emit('anotherevent');

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                instance
                    .emit('eventname')
                    .emit('anotherevent');

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>will fire an &quot;off:eventName&quot; event, when given 1 or more arguments</dt>
                <dd><pre><code>var anotherListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('off:eventname', anotherListener)
                        .should.equal(instance);

                anotherListener
                    .should.not.have.been.called;

                instance
                    .off('eventname', listener, context)
                        .should.equal(instance);

                anotherListener
                    .should.have.been.calledOnce
                    .and.have.been.calledWithExactly(listener, context, instance);

                instance
                    .on('eventname', listener, context)
                    .off('eventname', listener)
                        .should.equal(instance);

                anotherListener
                    .should.have.been.calledTwice;

                instance
                    .on('eventname', listener, context)
                    .off('eventname')
                        .should.equal(instance);

                anotherListener
                    .should.have.been.calledThrice;</code></pre></dd>
                <dt>can be given an object of events with listener functions</dt>
                <dd><pre><code>var anotherListener = this.spy(),
                    keptListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('anotherevent', anotherListener)
                    .on('keptevent', keptListener)
                    .emit('eventname')
                    .emit('anotherevent')
                    .emit('keptevent')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                keptListener
                    .should.have.been.calledOnce;

                listener.reset();
                anotherListener.reset();
                keptListener.reset();

                instance
                    .off({ eventname: listener, anotherevent: anotherListener })
                    .emit('eventname')
                    .emit('anotherevent')
                    .emit('keptevent')
                        .should.equal(instance);

                listener
                    .should.not.have.been.called;

                anotherListener
                    .should.not.have.been.called;

                keptListener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>can be given an object of events with strings pointing to functions on the context</dt>
                <dd><pre><code>var anotherListener = this.spy(),
                    keptListener = this.spy();

                instance
                    .on('eventname', listener, context)
                    .on('anotherevent', anotherListener, context)
                    .on('keptevent', keptListener)
                    .emit('eventname')
                    .emit('anotherevent')
                    .emit('keptevent')
                        .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                anotherListener
                    .should.have.been.calledOnce;

                listener.reset();
                anotherListener.reset();
                keptListener.reset();

                instance
                    .off({ eventname: 'listener', anotherevent: 'anotherListener' }, context)
                    .emit('eventname')
                    .emit('anotherevent')
                    .emit('keptevent')
                        .should.equal(instance);

                listener
                    .should.not.have.been.called;

                anotherListener
                    .should.not.have.been.called;

                keptListener
                    .should.have.been.calledOnce;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.once</h1>
              <dl>
                <dt>is given an event name, and a listener</dt>
                <dd><pre><code>instance.once('eventname', listener)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;</code></pre></dd>
                <dt>will fire the listener only once, and then will detatch itself</dt>
                <dd><pre><code>instance.once('eventname', listener)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce;</code></pre></dd>
                <dt>can be given an optional context</dt>
                <dd><pre><code>var context = {};

instance.once('eventname', listener, context)
    .should.equal(instance);

listener
    .should.have.not.been.called;

instance.emit('eventname')
    .should.equal(instance);

listener
    .should.have.been.calledOnce
    .and.always.have.been.calledOn(context);

instance.emit('eventname')
    .should.equal(instance);

listener
    .should.have.been.calledOnce
    .and.always.have.been.calledOn(context);</code></pre></dd>
                <dt>can include multiple event names in one string</dt>
                <dd><pre><code>instance.once('eventname anotherevent', listener, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);</code></pre></dd>
                <dt>can be given an object of events with listener functions</dt>
                <dd><pre><code>instance.once({ eventname: listener, anotherevent: listener }, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);</code></pre></dd>
                <dt>can be given an object of events with strings pointing to functions on the context</dt>
                <dd><pre><code>context = { listener: listener };

                instance.once({ eventname: 'listener', anotherevent: 'listener' }, context)
                    .should.equal(instance);

                listener
                    .should.have.not.been.called;

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('eventname')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                listener.reset();

                instance.emit('anotherevent')
                    .should.equal(instance);

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);

                instance.emit('anotherevent');

                listener
                    .should.have.been.calledOnce
                    .and.always.have.been.calledOn(context);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>

        <div class="fleur">h</div>
        </div>
    </div>
</body>
</html>